# Pandas 소개

판다스 패키지는 시계열이나 표형태를 다루기 위한 Series 클래스와 Dataframe 클래스를 제공한다.     

---------------------------

참고문헌   

[데이터 사이언스 스쿨](https://datascienceschool.net/01%20python/04.00%204%EC%9E%A5%20%ED%8C%90%EB%8B%A4%EC%8A%A4%20%EB%8D%B0%EC%9D%B4%ED%84%B0%20%EB%B6%84%EC%84%9D.html) 

-------------

## 1. Series 

시리즈 클래스 = value + index 이다.

### 1.1 시리즈 생성

인덱스를 지정하고 생성

```python
s = pd.Series([9904312, 3448737, 2890451, 2466052],
              index=["서울", "부산", "인천", "대구"])
s
---------------------------------------------------
서울    9904312
부산    3448737
인천    2890451
대구    2466052
dtype: int64
```

```python
s.index
-----------------------------
Index(['서울','부산','인천','대구'], dtype='objet')
```

```python
s.values #numpy에서 생성한 ndarray 와 같은 형태
-----------------------------
array([9904312, 3448737, 2890451, 2466052])  
```

인덱스 없이 생성

```python
pd.Series(range(10,14))
------------------------
0    10
1    11
2    12
3    13
dtype: int64
```

### 1.2 시리즈 인덱싱

```python
s = pd.Series([9904312, 3448737, 2890451, 2466052],
              index=["서울", "부산", "인천", "대구"])
```

#### 인덱싱

```python
s[1], s["부산"] #배열의 인덱스 방법도 가능하고, 인덱스 라벨도 가능한다
-----------------------------------
(3448737, 3448737)
```

#### 배열로 인덱싱 하기

```python
s[[0,3,1]]
-------------------------------------
서울    9904312
대구    2466052
부산    3448737
dtype: int64
```

```python
s[["서울", "대구", "부산"]]
-------------------------------------
서울    9904312
대구    2466052
부산    3448737
dtype: int64s[["서울", "대구", "부산"]]
```

#### 슬라이싱

```python
s[1:3]
----------------------
부산    3448737
인천    2890451
dtype: int64
```

#### 시리즈는 딕셔너리 자료형

```python
s = pd.Series([9904312, 3448737, 2890451, 2466052],
              index=["서울", "부산", "인천", "대구"])
```



시리즈 객체는 딕셔너리 객체와 동일한 연산을 수행한다.

```python
'서울' in s
-------------------
True
```

시리즈 순회

```python
for k, v in s.items():
    print(f"{k}={v}")
-------------------------
서울=9904312
부산=3448737
인천=2890451
대구=2466052
```

데이터 갱신, 추가, 삭제

```python
s['부산'] = 9900000
del s['서울']
s
-----------------------------
부산    9900000
인천    2890451
대구    2466052
dtype: int64
```



###  1.3 인덱스 기반 연산

pandas는 인덱스가 같은 값에 대해서 매핑한 다음 연산을 수행하는 방법을 제공한다.

```python
인구_2015 = pd.Series([9904312, 3448737, 2890451, 2466052],
              index=["서울", "부산", "인천", "대구"])
인구_2010 = pd.Series({"서울": 9631482, "부산": 3393191, "인천": 2632035, "대전": 1490158})
```

인덱스와 상관없이 계산한 경우는 다음과 같이 엉뚱한 값이 나온다. 

```python
인구_2015.values-인구_2010.values
-------------------------------------
array([272830,  55546, 258416, 975894], dtype=int64)
```

인덱스 기반 연산

```python
인구_2015-인구_2010
--------------------------
대구         NaN
대전         NaN
부산     55546.0
서울    272830.0
인천    258416.0
dtype: float64
```

인덱스 기반 연산을 수행한후 NaN을 제거

``` python
ds = 인구_2015-인구_2010
ds[ds.notnull()]
--------------------------------
부산     55546.0
서울    272830.0
인천    258416.0
dtype: float64
```

인구증가율은 다음과 같이 구할 수 있다.

``` python
rs = (인구_2015-인구_2010)/인구_2010  * 100
rs = rs[rs.notnull()]
rs
-----------------------------------------
부산    1.636984
서울    2.832690
인천    9.818107
dtype: float64
```

## 2. 데이터프레임 기초

시리즈는 1차원 벡터데이터라면 DataFrame 클래스는 2차원 테이블 형태, Series 는 row index 만 가지고 있다면  DataFrame 은 row index 뿐만 아니라 column index 도 가지고 있다. 3개의 주요 요소는 다음과 같다.

* values:  ndarray 타입으로 값을 가지고 있다.
* columns: 컬럼에 대한 인덱스이다.
* index: 행에 대한 인덱스이다.

### 2.1 데이터프레임 생성

데이터,  row index, column index를 준비한 다음에 dataframe 에 넣는다.

```python
data = {
    "2015": [9904312, 3448737, 2890451, 2466052],
    "2010": [9631482, 3393191, 2632035, 2431774],
    "2005": [9762546, 3512547, 2517680, 2456016],
    "2000": [9853972, 3655437, 2466338, 2473990],
    "지역": ["수도권", "경상권", "수도권", "경상권"],
    "2010-2015 증가율": [0.0283, 0.0163, 0.0982, 0.0141]
}
columns = ["지역", "2015", "2010", "2005", "2000", "2010-2015 증가율"]
index = ["서울", "부산", "인천", "대구"]
df = pd.DataFrame(data, index=index, columns=columns)
df
```

|      |   지역 |    2015 |    2010 |    2005 |    2000 | 2010-2015 증가율 |
| ---: | -----: | ------: | ------: | ------: | ------: | ---------------- |
| 서울 | 수도권 | 9904312 | 9631482 | 9762546 | 9853972 | 0.0283           |
| 부산 | 경상권 | 3448737 | 3393191 | 3512547 | 3655437 | 0.0163           |
| 인천 | 수도권 | 2890451 | 2632035 | 2517680 | 2466338 | 0.0982           |
| 대구 | 경상권 | 2466052 | 2431774 | 2456016 | 2473990 | 0.0141           |

df.values, df.columns, df.index  정보 확인하기

```python
df.values
-------------------------------------------------------------------
array([['수도권', 9904312, 9631482, 9762546, 9853972, 0.0283],
       ['경상권', 3448737, 3393191, 3512547, 3655437, 0.0163],
       ['수도권', 2890451, 2632035, 2517680, 2466338, 0.0982],
       ['경상권', 2466052, 2431774, 2456016, 2473990, 0.0141]], dtype=object)
df.columns
```

```python
df.columns
--------------------------------------------------------------------
Index(['지역', '2015', '2010', '2005', '2000', '2010-2015 증가율'], dtype='object')
```

```python
df.index
---------------------------------------------------------------------
Index(['서울', '부산', '인천', '대구'], dtype='object')
```

### 2.2 열단위 데이터 갱신

``` python
df["2010-2015 증가율"] = df["2010-2015 증가율"] * 100
df
```

|      |   지역 |    2015 |    2010 |    2005 |    2000 | 2010-2015 증가율 |
| ---: | -----: | ------: | ------: | ------: | ------: | ---------------: |
| 서울 | 수도권 | 9904312 | 9631482 | 9762546 | 9853972 |             2.83 |
| 부산 | 경상권 | 3448737 | 3393191 | 3512547 | 3655437 |             1.63 |
| 인천 | 수도권 | 2890451 | 2632035 | 2517680 | 2466338 |             9.82 |
| 대구 | 경상권 | 2466052 | 2431774 | 2456016 | 2473990 |             1.41 |

```python
df["2005-2010 증가율"] = ((df["2010"] - df["2005"]) / df["2005"] * 100).round(2)
df
```

|      |   지역 |    2015 |    2010 |    2005 |    2000 | 2010-2015 증가율 | 2005-2010 증가율 |
| ---: | -----: | ------: | ------: | ------: | ------: | ---------------: | ---------------: |
| 서울 | 수도권 | 9904312 | 9631482 | 9762546 | 9853972 |             2.83 |            -1.34 |
| 부산 | 경상권 | 3448737 | 3393191 | 3512547 | 3655437 |             1.63 |            -3.40 |
| 인천 | 수도권 | 2890451 | 2632035 | 2517680 | 2466338 |             9.82 |             4.54 |
| 대구 | 경상권 | 2466052 | 2431774 | 2456016 | 2473990 |             1.41 |            -0.99 |

### 2.3 열인덱싱

열 라벨을 key값으로 넣어주면 series 객체를 반환하고 List 로 묶어서 반환하면 부분 데이터프레임 객체가 반환된다.

#### 한개의 열 추출

```python
df["지역"]
--------------------
서울    수도권
부산    경상권
인천    수도권
대구    경상권
Name: 지역, dtype: object
```

```python
type(df['지역'])
---------------------------
pandas.core.series.Series
```

#### 부분 데이터프레임 추출

```python
df[['2010','2015']]
```

|      |    2010 |    2015 |
| ---: | ------: | ------: |
| 서울 | 9631482 | 9904312 |
| 부산 | 3393191 | 3448737 |
| 인천 | 2632035 | 2890451 |
| 대구 | 2431774 | 2466052 |

```python
type(df[['2010','2015']])
--------------------------------
pandas.core.frame.DataFrame
```

### 2.4 행인덱싱

행단위로 인덱싱하려면 슬라이싱을 해야 한다. (주의) 열과 같이 한개의 값으로 인덱싱 되지 않는다. 

```python
df[:1]
```

|      |   지역 |    2015 |    2010 |    2005 |    2000 | 2010-2015 증가율 | 2005-2010 증가율 |
| ---: | -----: | ------: | ------: | ------: | ------: | ---------------: | ---------------: |
| 서울 | 수도권 | 9904312 | 9631482 | 9762546 | 9853972 |             2.83 |            -1.34 |

```python
df['서울':'서울']
```

|      |   지역 |    2015 |    2010 |    2005 |    2000 | 2010-2015 증가율 | 2005-2010 증가율 |
| ---: | -----: | ------: | ------: | ------: | ------: | ---------------: | ---------------: |
| 서울 | 수도권 | 9904312 | 9631482 | 9762546 | 9853972 |             2.83 |            -1.34 |

```python
df[1:3]
```

|      |   지역 |    2015 |    2010 |    2005 |    2000 | 2010-2015 증가율 | 2005-2010 증가율 |
| ---: | -----: | ------: | ------: | ------: | ------: | ---------------: | ---------------: |
| 부산 | 경상권 | 3448737 | 3393191 | 3512547 | 3655437 |             1.63 |            -3.40 |
| 인천 | 수도권 | 2890451 | 2632035 | 2517680 | 2466338 |             9.82 |             4.54 |

```python
df["부산":"인천"]
```

|      |   지역 |    2015 |    2010 |    2005 |    2000 | 2010-2015 증가율 | 2005-2010 증가율 |
| ---: | -----: | ------: | ------: | ------: | ------: | ---------------: | ---------------: |
| 부산 | 경상권 | 3448737 | 3393191 | 3512547 | 3655437 |             1.63 |            -3.40 |
| 인천 | 수도권 | 2890451 | 2632035 | 2517680 | 2466338 |             9.82 |             4.54 |

### 2.5  개별 데이터 인덱싱

```python
df["2015"]["서울"]
--------------------------
9904312
```



## 3. 데이터프레임 고급인덱싱

판다스는 numpy와 같이 쉼표를 사용한 2차원 인덱싱을 지원한다. 이에 대한 지원 함수는 다음과 같다.

* loc: 레이블 기반
* iloc: 순서를 나타내는 정수 기반  

### 3.1 loc 인덱서

* 행선택: df.loc[행인덱싱값]
* 행열선택: df.loc[행인덱싱값, 열인덱싱값]

```python
df = pd.DataFrame(np.arange(10, 22).reshape(3, 4),
                  index=["a", "b", "c"],
                  columns=["A", "B", "C", "D"])
```

|      |    A |    B |    C |    D |
| ---: | ---: | ---: | ---: | ---: |
|    a |   10 |   11 |   12 |   13 |
|    b |   14 |   15 |   16 |   17 |
|    c |   18 |   19 |   20 |   21 |

#### 행 선택

한개의 행만 선택

```python
df.loc['a']
```

부분 행 선택

```python
df.loc['b':'c'] #연속된 행
df.loc[['b','c']] # 특정행만 선택
```

조건부행 선택

```python
df.log[df.A>15]
```



#### 행,열 선택

한개의 요소 선택

```python
df.loc['a','B']
```

 부분행 선택

```python
df.loc["b":, "A"]
```

 한개의 행 추출

```python
df.loc["b", :]
```

부분 데이터프레임 추출

```python
df.loc[["a", "b"], ["B", "D"]]
```

조건부 데이터프레임 추출

```python
df.loc[df.A > 10, ["C", "D"]]
```

### 3.1 iloc 인덱서

loc 인덱서와 사용법은 유사하다. 라벨이 아니라 순서를 나타내는 정수 인덱스만 받는다.     

(단점) 조건 필터링이 쉽지 않다. 잘 찾아서 해보면 되긴 된다.

요소 선택

```pyhon
df.iloc[0, 1]
```

부분행 선택

```python
df.iloc[:2, 2]
```

부분데이터 프레임 추출

```python
df.iloc[2:3, 1:3]
```

조건부 데이터프레임 추출

```python
df.iloc[list(df.iloc[:,0]>10), [2,3]] # df.loc[df.A > 10, ["C", "D"]]
```

## 4. 데이터프레임 조작

### 4.1 apply

apply를 이용하면 열(또는 행)을 반복하여 함수를 적용시킨다.     

반복문을 쓰지 않고도 코딩이 가능하다. 

```python
df = pd.DataFrame({
    'A': [1, 3, 4, 3, 4],
    'B': [2, 3, 1, 2, 3],
    'C': [1, 5, 2, 4, 4]
})
```

|      |  A   |  B   |  C   |
| :--: | :--: | :--: | :--: |
|  0   |  1   |  2   |  1   |
|  1   |  3   |  3   |  5   |
|  2   |  4   |  1   |  2   |
|  3   |  3   |  2   |  4   |
|  4   |  4   |  3   |  4   |

열에 대해서  apply  함수 적용

```python
f = lambda x: max(x) - min(x) # 범위를 구하는 익명함수
df.apply(f) # 모든 열에 대해서 범위를 구한다.
--------------------------
A    3
B    2
C    4
dtype: int64
```

행에 대해서 apply  함수 적용

```python
df.apply(lambda x: x.max() - x.min(), axis=1)
----------------------------
0    1
1    2
2    3
3    2
4    1
dtype: int64
```

열에 대한 빈도수 구하기 (응용)

```python
df.apply(pd.value_counts)
---------------------------------
    A	B	C
1	1.0	1.0	1.0
2	NaN	2.0	1.0
3	2.0	2.0	NaN
4	2.0	NaN	2.0
5	NaN	NaN	1.0
```

타이타닉에서 adult/child 레이블링하기 (응용)

```python
import seaborn as sns
titanic = sns.load_dataset('titanic')
f= lambda r: "adult" if r.age >= 20 else "child"
titanic["adult/child"] = titanic.apply(f, axis=1)
```

### 4.2 fillna

NaN 값을 대체하는 값으로 채워 넣어준다.

```python
df.apply(pd.value_counts).fillna(0.0)
------------------------------
    A 	B	C
1	1.0	1.0	1.0
2	0.0	2.0	1.0
3	2.0	2.0	0.0
4	2.0	0.0	2.0
5	0.0	0.0	1.0
```

### 4.3 astype

데이터의 자료형을 바꾼다. 

```python
df.apply(pd.value_counts).fillna(0).astype(int)
---------------------------------------

    A	B	C
1	1	1	1
2	0	2	1
3	2	2	0
4	2	0	2
5	0	0	1
```

## 5. 데이터프레임 인덱스 조작

``` python
np.random.seed(0)
df1 = pd.DataFrame(np.vstack([list('ABCDE'),
                              np.round(np.random.rand(3, 5), 2)]).T,
                   columns=["C1", "C2", "C3", "C4"])
df1
```

|      |   C1 |   C2 |   C3 |   C4 |
| ---: | ---: | ---: | ---: | ---: |
|    0 |    A | 0.55 | 0.65 | 0.79 |
|    1 |    B | 0.72 | 0.44 | 0.53 |
|    2 |    C |  0.6 | 0.89 | 0.57 |
|    3 |    D | 0.54 | 0.96 | 0.93 |
|    4 |    E | 0.42 | 0.38 | 0.07 |

### 5.1 set_index

기존 인덱스를 없애고 특정한 열을 인덱스로 설정한다.    

내가 원하는 필터링이나 피봇을 적용하고 싶을 때 사용한다. 

```python
df2 = df1.set_index("C1")
df2
---------------------------------------

      C2	 C3	     C4
C1			
A	0.55	0.65	0.79
B	0.72	0.44	0.53
C	0.6	    0.89	0.57
D	0.54	0.96	0.93
E	0.42	0.38	0.07
```

### 5.2 reset_index

데이터 프레임의 인덱스를 정수로 된인덱스로 바꾸고 기존 인덱스열은 일반열로 바꾼다. 

```python
df2.reset_index()
-----------------------------------------
    C1   C2	     C3  	C4
0	A	0.55	0.65	0.79
1	B	0.72	0.44	0.53
2	C	 0.6	0.89	0.57
3	C	0.54	0.96	0.93
4	E	0.42	0.38	0.07
```

### 5.3 다중 인덱스

인덱스에 리스트의 리스트로 넣으면 다중 인덱스를 가지게 된다.

```python
data = np.round(np.random.randn(5, 4), 2)
df = pd.DataFrame(data,columns=[["A", "A", "B", "B"],["C1", "C2", "C1", "C2"]])
df
```

|      | A     |       | B     |       |
| ---: | :---- | :---- | :---- | :---- |
|      | C1    | C2    | C1    | C2    |
|    0 | -1.08 | 1.40  | 1.79  | -0.57 |
|    1 | 0.18  | -0.46 | -1.09 | 0.64  |
|    2 | -0.39 | -0.78 | 1.00  | -1.93 |
|    3 | 0.25  | -0.03 | -0.14 | -0.19 |
|    4 | 0.45  | -0.99 | -0.23 | -1.65 |

## 6. Merge

### 6.1 merge

database에서 join과 같이 두개의 테이블을 결합할때 merge를 활용한다.

```python
df1 = pd.DataFrame({
    '고객번호': [1001, 1002, 1003, 1004, 1005, 1006, 1007],
    '이름': ['둘리', '도우너', '또치', '길동', '희동', '마이콜', '영희']
}, columns=['고객번호', '이름'])
df1
------------------------------------
  고객번호	 이름
0	1001	둘리
1	1002	도우너
2	1003	또치
3	1004	길동
4	1005	희동
5	1006	마이콜
6	1007	영희
```

```python
df2 = pd.DataFrame({
    '고객번호': [1001, 1001, 1005, 1006, 1008, 1001],
    '금액': [10000, 20000, 15000, 5000, 100000, 30000]
}, columns=['고객번호', '금액'])
df2
---------------------------------------
   고객번호	   금액
0	1001	10000
1	1001	20000
2	1005	15000
3	1006	5000
4	1008	100000
5	1001	30000
```

#### inner join

공통열을 기준으로 inner join 한다.

```python
pd.merge(df1, df2)
-----------------------
	고객번호	이름	금액
0	1001	둘리	10000
1	1001	둘리	20000
2	1001	둘리	30000
3	1005	희동	15000
4	1006	마이콜	5000
```

#### outer join

```python
pd.merge(df1, df2, how='outer')
--------------------------------

고객번호	이름	금액
0	1001	둘리	10000.0
1	1001	둘리	20000.0
2	1001	둘리	30000.0
3	1002	도우너	NaN
4	1003	또치	NaN
5	1004	길동	NaN
6	1005	희동	15000.0
7	1006	마이콜	5000.0
8	1007	영희	NaN
9	1008	NaN	100000.0
```

#### left join

```python
pd.merge(df1, df2, how='left')
--------------------------------
고객번호	이름	금액
0	1001	둘리	10000.0
1	1001	둘리	20000.0
2	1001	둘리	30000.0
3	1002	도우너	NaN
4	1003	또치	NaN
5	1004	길동	NaN
6	1005	희동	15000.0
7	1006	마이콜	5000.0
8	1007	영희	NaN
```

#### right join

```python
pd.merge(df1, df2, how='right')
------------------------------------
고객번호	이름	금액
0	1001	둘리	10000
1	1001	둘리	20000
2	1001	둘리	30000
3	1005	희동	15000
4	1006	마이콜	5000
5	1008	NaN	100000
```



## ToDo

* apply 함수 사용법
